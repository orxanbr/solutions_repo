{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"\ud83c\udfaf Investigating the Range as a Function of the Angle of Projection \ud83d\udccc Step 1: Deriving the Equations Assume a projectile is launched from height \\(h_0\\) with initial velocity \\(v_0\\) at angle \\(\\theta\\) from the horizontal. We break motion into horizontal (x) and vertical (y) components. a. Horizontal Motion (no acceleration) \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Constant horizontal velocity No air resistance Uniform linear motion b. Vertical Motion (with gravity) \\[ y(t) = h_0 + v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] Affected by gravitational acceleration \\(g\\) Follows a parabolic trajectory \ud83d\udccc Step 2: Time of Flight To find the time when the projectile hits the ground, set \\(y(t) = 0\\) : \\[ 0 = h_0 + v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] This is a quadratic equation in \\(t\\) : \\[ \\frac{1}{2}gt^2 - v_0 \\sin(\\theta) \\cdot t - h_0 = 0 \\] Solving with the quadratic formula: \\[ t = \\frac{v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2gh_0}}{g} \\] (We discard the negative root because time must be positive.) \ud83d\udccc Step 3: Calculating Range Using the horizontal motion: \\[ R = x(t_{\\text{flight}}) = v_0 \\cos(\\theta) \\cdot t_{\\text{flight}} \\] Substitute the time of flight: \\[ R(\\theta) = v_0 \\cos(\\theta) \\cdot \\left( \\frac{v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2gh_0}}{g} \\right) \\] Special case: When \\(h_0 = 0\\) , the formula simplifies to: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] \ud83d\udd04 Family of Solutions A \"family of solutions\" refers to how initial conditions affect the trajectory: Parameter Effect on Trajectory \\( v_0 \\) Increases both range and height \\( \\theta \\) Changes range & height; max range at 45\u00b0 (if \\( h_0 = 0 \\) ) \\( h_0 \\) Increases total time of flight and hence range \\( g \\) Stronger gravity reduces range and hang time So varying any of these creates a new curve , but all follow the same general mathematical form \u2014 that\u2019s your family of solutions . \ud83d\udccc Step 4: Analysis of the Range \ud83d\udd0d Key Observations The range is maximum at \\(\\theta = 45^\\circ\\) when \\(h_0 = 0\\) . The function is symmetric around \\(45^\\circ\\) . Range increases quadratically with \\(v_0\\) . Higher launch height \\(h_0\\) extends the range. Visualizing the Range","title":"\ud83c\udfaf Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83c\udfaf Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-1-deriving-the-equations","text":"Assume a projectile is launched from height \\(h_0\\) with initial velocity \\(v_0\\) at angle \\(\\theta\\) from the horizontal. We break motion into horizontal (x) and vertical (y) components.","title":"\ud83d\udccc Step 1: Deriving the Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#a-horizontal-motion-no-acceleration","text":"\\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Constant horizontal velocity No air resistance Uniform linear motion","title":"a. Horizontal Motion (no acceleration)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#b-vertical-motion-with-gravity","text":"\\[ y(t) = h_0 + v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] Affected by gravitational acceleration \\(g\\) Follows a parabolic trajectory","title":"b. Vertical Motion (with gravity)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-2-time-of-flight","text":"To find the time when the projectile hits the ground, set \\(y(t) = 0\\) : \\[ 0 = h_0 + v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] This is a quadratic equation in \\(t\\) : \\[ \\frac{1}{2}gt^2 - v_0 \\sin(\\theta) \\cdot t - h_0 = 0 \\] Solving with the quadratic formula: \\[ t = \\frac{v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2gh_0}}{g} \\] (We discard the negative root because time must be positive.)","title":"\ud83d\udccc Step 2: Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-3-calculating-range","text":"Using the horizontal motion: \\[ R = x(t_{\\text{flight}}) = v_0 \\cos(\\theta) \\cdot t_{\\text{flight}} \\] Substitute the time of flight: \\[ R(\\theta) = v_0 \\cos(\\theta) \\cdot \\left( \\frac{v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2gh_0}}{g} \\right) \\] Special case: When \\(h_0 = 0\\) , the formula simplifies to: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"\ud83d\udccc Step 3: Calculating Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"A \"family of solutions\" refers to how initial conditions affect the trajectory: Parameter Effect on Trajectory \\( v_0 \\) Increases both range and height \\( \\theta \\) Changes range & height; max range at 45\u00b0 (if \\( h_0 = 0 \\) ) \\( h_0 \\) Increases total time of flight and hence range \\( g \\) Stronger gravity reduces range and hang time So varying any of these creates a new curve , but all follow the same general mathematical form \u2014 that\u2019s your family of solutions .","title":"\ud83d\udd04 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-4-analysis-of-the-range","text":"","title":"\ud83d\udccc Step 4: Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"The range is maximum at \\(\\theta = 45^\\circ\\) when \\(h_0 = 0\\) . The function is symmetric around \\(45^\\circ\\) . Range increases quadratically with \\(v_0\\) . Higher launch height \\(h_0\\) extends the range.","title":"\ud83d\udd0d Key Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#visualizing-the-range","text":"","title":"Visualizing the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"1. Theoretical Foundation Start with the nonlinear differential equation describing the forced damped pendulum: $$ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $$ Where: \\[ \\begin{aligned} \\theta & : \\text{Angular displacement} \\\\ b & : \\text{Damping coefficient} \\\\ g & : \\text{Acceleration due to gravity} \\\\ L & : \\text{Length of the pendulum} \\\\ A & : \\text{Amplitude of the driving force} \\\\ \\omega & : \\text{Angular frequency of the driving force} \\end{aligned} \\] Small-Angle Approximation For small oscillations, approximate \\( \\sin\\theta \\approx \\theta \\) . The equation becomes linear: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a second-order linear nonhomogeneous differential equation with periodic forcing. Resonance Conditions The natural frequency of the pendulum (undamped, unforced) is: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] Resonance occurs when the driving frequency \\( \\omega \\) approaches the natural frequency: \\[ \\omega \\approx \\omega_0 \\] At this point, the system exhibits maximum amplitude (resonant response), especially when damping is low. 2. Analysis of Dynamics Analyze how varying parameters affects behavior: Damping coefficient \\(( b )\\) :Reduces amplitude and energy over time Driving amplitude \\(( A )\\) :Controls how strongly the pendulum is forced Driving frequency \\(( \\omega )\\) :Determines synchronization, resonance, or chaos Regular to Chaotic Transition For some values of \\(( A )\\) and \\(( \\omega )\\) , the system shifts from: Periodic motion Quasiperiodic motion Chaotic motion This transition is visualized using phase space plots and Poincar\u00e9 sections. 3. Practical Applications Discuss real-world systems that model a forced damped pendulum: Energy harvesting devices Suspension bridges under wind or vibration Driven RLC circuits in electronics Biomechanical systems like human gait 4.Implementation We create a computational model to simulate the motion of a forced damped pendulum and visualize: Time evolution Phase diagram Poincar\u00e9 section","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Start with the nonlinear differential equation describing the forced damped pendulum: $$ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $$ Where: \\[ \\begin{aligned} \\theta & : \\text{Angular displacement} \\\\ b & : \\text{Damping coefficient} \\\\ g & : \\text{Acceleration due to gravity} \\\\ L & : \\text{Length of the pendulum} \\\\ A & : \\text{Amplitude of the driving force} \\\\ \\omega & : \\text{Angular frequency of the driving force} \\end{aligned} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, approximate \\( \\sin\\theta \\approx \\theta \\) . The equation becomes linear: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a second-order linear nonhomogeneous differential equation with periodic forcing.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"The natural frequency of the pendulum (undamped, unforced) is: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] Resonance occurs when the driving frequency \\( \\omega \\) approaches the natural frequency: \\[ \\omega \\approx \\omega_0 \\] At this point, the system exhibits maximum amplitude (resonant response), especially when damping is low.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Analyze how varying parameters affects behavior: Damping coefficient \\(( b )\\) :Reduces amplitude and energy over time Driving amplitude \\(( A )\\) :Controls how strongly the pendulum is forced Driving frequency \\(( \\omega )\\) :Determines synchronization, resonance, or chaos Regular to Chaotic Transition For some values of \\(( A )\\) and \\(( \\omega )\\) , the system shifts from: Periodic motion Quasiperiodic motion Chaotic motion This transition is visualized using phase space plots and Poincar\u00e9 sections.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Discuss real-world systems that model a forced damped pendulum: Energy harvesting devices Suspension bridges under wind or vibration Driven RLC circuits in electronics Biomechanical systems like human gait","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4implementation","text":"We create a computational model to simulate the motion of a forced damped pendulum and visualize: Time evolution Phase diagram Poincar\u00e9 section","title":"4.Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 1. Newton\u2019s Law of Universal Gravitation Newton\u2019s Law of Universal Gravitation tells us the gravitational force between two masses M and m separated by a distance r is: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] \\( G \\) = Gravitational constant \\( M \\) = Mass of central object \\( m \\) = Orbiting mass \\( r \\) = Orbital radius 2. Centripetal Force for Circular Motion An object moving in a circle must constantly be accelerated toward the center to keep changing its direction. This acceleration requires a force, known as centripetal force , given by: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] 3. Equating Forces Since the gravitational force provides the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\( m \\) on both sides: \\[ \\frac{G M}{r^2} = \\frac{v^2}{r} \\] Multiply both sides by \\( r \\) : \\[ v^2 = \\frac{G M}{r} \\] 4. Orbital Period Formula Orbital period is the time to complete one full orbit: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(( v = \\sqrt{\\frac{G M}{r}} ):\\) \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] 5. Final Form \u2013 Kepler\u2019s Third Law Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] This is Kepler's Third Law in mathematical form: \\[ T^2 \\propto r^3 \\] Computational Model","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-newtons-law-of-universal-gravitation","text":"Newton\u2019s Law of Universal Gravitation tells us the gravitational force between two masses M and m separated by a distance r is: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] \\( G \\) = Gravitational constant \\( M \\) = Mass of central object \\( m \\) = Orbiting mass \\( r \\) = Orbital radius","title":"1. Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-centripetal-force-for-circular-motion","text":"An object moving in a circle must constantly be accelerated toward the center to keep changing its direction. This acceleration requires a force, known as centripetal force , given by: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\]","title":"2. Centripetal Force for Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-equating-forces","text":"Since the gravitational force provides the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\( m \\) on both sides: \\[ \\frac{G M}{r^2} = \\frac{v^2}{r} \\] Multiply both sides by \\( r \\) : \\[ v^2 = \\frac{G M}{r} \\]","title":"3. Equating Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-orbital-period-formula","text":"Orbital period is the time to complete one full orbit: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(( v = \\sqrt{\\frac{G M}{r}} ):\\) \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\]","title":"4. Orbital Period Formula"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-final-form-keplers-third-law","text":"Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] This is Kepler's Third Law in mathematical form: \\[ T^2 \\propto r^3 \\]","title":"5. Final Form \u2013 Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model","text":"","title":"Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities \ud83d\udccc Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first , second , and third cosmic velocities define the thresholds for orbiting , escaping , and leaving a star system . These principles underpin modern space exploration \u2014 from launching satellites to interplanetary and interstellar missions. \ud83d\ude80 Definitions \ud83d\udef0\ufe0f First Cosmic Velocity (Orbital Velocity) The minimum velocity required to enter a stable circular orbit around a planet without additional propulsion : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] \ud83c\udf0d Second Cosmic Velocity (Escape Velocity) The minimum velocity needed to escape a planet\u2019s gravitational field without further propulsion : \\[ v_2 = \\sqrt{2 \\cdot \\frac{GM}{R}} \\] \ud83c\udf0c Third Cosmic Velocity (Stellar Escape Velocity) The velocity required to completely leave a planetary system (e.g., escape from the Sun\u2019s gravity from Earth\u2019s orbit): \\[ v_3 = \\sqrt{2 \\cdot v_{sun}^2 + v_2^2} \\] Where: - \\( v_{sun} \\) is the orbital speed of the planet around the Sun. \ud83d\udcd0 Parameters \\( G = 6.67430 \\times 10^{-11} \\ \\text{m}^3/\\text{kg}/\\text{s}^2 \\) (Gravitational Constant) \\( M \\) : Mass of the celestial body \\( R \\) : Radius of the celestial body \\( v_{sun} \\) : Orbital velocity of the planet around the Sun \ud83e\uddea Python Simulation Code import math import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant # Celestial body data bodies = { \"Earth\": {\"radius\": 6.371e6, \"mass\": 5.972e24}, \"Mars\": {\"radius\": 3.3895e6, \"mass\": 6.4171e23}, \"Jupiter\": {\"radius\": 6.9911e7, \"mass\": 1.898e27} } results = [] for body, data in bodies.items(): r = data[\"radius\"] M = data[\"mass\"] v1 = math.sqrt(G * M / r) v2 = math.sqrt(2 * G * M / r) orbit_speeds = {\"Earth\": 29.78e3, \"Mars\": 24.077e3, \"Jupiter\": 13.07e3} v_sun = orbit_speeds[body] v3 = math.sqrt(2 * v_sun**2 + v2**2) results.append({ \"Celestial Body\": body, \"First Cosmic Velocity (km/s)\": v1 / 1000, \"Second Cosmic Velocity (km/s)\": v2 / 1000, \"Third Cosmic Velocity (km/s)\": v3 / 1000 }) df = pd.DataFrame(results) print(df) # Plotting plt.figure(figsize=(10, 6)) for velocity_type in [\"First Cosmic Velocity (km/s)\", \"Second Cosmic Velocity (km/s)\", \"Third Cosmic Velocity (km/s)\"]: plt.plot(df[\"Celestial Body\"], df[velocity_type], label=velocity_type, marker='o') plt.title(\"Cosmic Velocities for Different Celestial Bodies\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.legend() plt.grid(True) plt.show() \ud83d\udcca Results Table Celestial Body First Cosmic Velocity (km/s) Second Cosmic Velocity (km/s) Third Cosmic Velocity (km/s) Earth ~7.9 ~11.2 ~42.1 Mars ~3.6 ~5.0 ~34.1 Jupiter ~42.1 ~59.5 ~70.6 \ud83d\ude80 Importance in Space Exploration First Cosmic Velocity : Enables satellites and space stations to maintain orbits (e.g., GPS, ISS). Second Cosmic Velocity : Allows missions to leave the planet \u2014 e.g., Mars rovers, interplanetary probes. Third Cosmic Velocity : Required for escaping the solar system \u2014 e.g., Voyager , Pioneer , future interstellar missions . \u2705 Conclusion Understanding and calculating cosmic velocities is fundamental for designing trajectories, estimating fuel needs, and ensuring the success of space missions \u2014 from satellite deployment to exploring distant worlds and beyond.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first , second , and third cosmic velocities define the thresholds for orbiting , escaping , and leaving a star system . These principles underpin modern space exploration \u2014 from launching satellites to interplanetary and interstellar missions.","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"\ud83d\ude80 Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The minimum velocity required to enter a stable circular orbit around a planet without additional propulsion : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\]","title":"\ud83d\udef0\ufe0f First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The minimum velocity needed to escape a planet\u2019s gravitational field without further propulsion : \\[ v_2 = \\sqrt{2 \\cdot \\frac{GM}{R}} \\]","title":"\ud83c\udf0d Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-stellar-escape-velocity","text":"The velocity required to completely leave a planetary system (e.g., escape from the Sun\u2019s gravity from Earth\u2019s orbit): \\[ v_3 = \\sqrt{2 \\cdot v_{sun}^2 + v_2^2} \\] Where: - \\( v_{sun} \\) is the orbital speed of the planet around the Sun.","title":"\ud83c\udf0c Third Cosmic Velocity (Stellar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters","text":"\\( G = 6.67430 \\times 10^{-11} \\ \\text{m}^3/\\text{kg}/\\text{s}^2 \\) (Gravitational Constant) \\( M \\) : Mass of the celestial body \\( R \\) : Radius of the celestial body \\( v_{sun} \\) : Orbital velocity of the planet around the Sun","title":"\ud83d\udcd0 Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-code","text":"import math import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant # Celestial body data bodies = { \"Earth\": {\"radius\": 6.371e6, \"mass\": 5.972e24}, \"Mars\": {\"radius\": 3.3895e6, \"mass\": 6.4171e23}, \"Jupiter\": {\"radius\": 6.9911e7, \"mass\": 1.898e27} } results = [] for body, data in bodies.items(): r = data[\"radius\"] M = data[\"mass\"] v1 = math.sqrt(G * M / r) v2 = math.sqrt(2 * G * M / r) orbit_speeds = {\"Earth\": 29.78e3, \"Mars\": 24.077e3, \"Jupiter\": 13.07e3} v_sun = orbit_speeds[body] v3 = math.sqrt(2 * v_sun**2 + v2**2) results.append({ \"Celestial Body\": body, \"First Cosmic Velocity (km/s)\": v1 / 1000, \"Second Cosmic Velocity (km/s)\": v2 / 1000, \"Third Cosmic Velocity (km/s)\": v3 / 1000 }) df = pd.DataFrame(results) print(df) # Plotting plt.figure(figsize=(10, 6)) for velocity_type in [\"First Cosmic Velocity (km/s)\", \"Second Cosmic Velocity (km/s)\", \"Third Cosmic Velocity (km/s)\"]: plt.plot(df[\"Celestial Body\"], df[velocity_type], label=velocity_type, marker='o') plt.title(\"Cosmic Velocities for Different Celestial Bodies\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.legend() plt.grid(True) plt.show()","title":"\ud83e\uddea Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#results-table","text":"Celestial Body First Cosmic Velocity (km/s) Second Cosmic Velocity (km/s) Third Cosmic Velocity (km/s) Earth ~7.9 ~11.2 ~42.1 Mars ~3.6 ~5.0 ~34.1 Jupiter ~42.1 ~59.5 ~70.6","title":"\ud83d\udcca Results Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity : Enables satellites and space stations to maintain orbits (e.g., GPS, ISS). Second Cosmic Velocity : Allows missions to leave the planet \u2014 e.g., Mars rovers, interplanetary probes. Third Cosmic Velocity : Required for escaping the solar system \u2014 e.g., Voyager , Pioneer , future interstellar missions .","title":"\ud83d\ude80 Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Understanding and calculating cosmic velocities is fundamental for designing trajectories, estimating fuel needs, and ensuring the success of space missions \u2014 from satellite deployment to exploring distant worlds and beyond.","title":"\u2705 Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83d\ude80 Trajectories of a Freely Released Payload Near Earth \ud83d\udccc Motivation When an object is released from a moving rocket near Earth, its trajectory is governed by initial velocity, release angle, altitude, and the gravitational pull of Earth. This creates a spectrum of possible paths \u2014 elliptical , parabolic , or hyperbolic \u2014 depending on its energy and direction . Understanding these trajectories is crucial for: Orbital insertion Satellite deployment Reentry planning Escape missions \ud83c\udf0d Theoretical Background \ud83e\uddf2 Newton\u2019s Law of Gravitation \\[ F = \\frac{GMm}{r^2} \\] Where: - \\( F \\) is the gravitational force - \\( G = 6.67430 \\times 10^{-11} \\ \\text{m}^3/\\text{kg}/\\text{s}^2 \\) - \\( M \\) is Earth\u2019s mass - \\( m \\) is the payload mass - \\( r \\) is the distance from Earth's center \ud83d\udd04 Equation of Motion (2D) To simulate motion in a plane, we use Newton's Second Law and integrate position and velocity: \\[ \\vec{a} = - \\frac{GM}{r^3} \\vec{r} \\] We use numerical methods like Euler or Runge-Kutta (RK4) to simulate the motion over time. \u2728 Types of Trajectories Elliptical : Bound orbit (total mechanical energy < 0) Parabolic : Escape at exactly escape velocity (total energy = 0) Hyperbolic : Escape with excess velocity (total energy > 0) The total specific energy: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \ud83e\uddea Python Simulation Code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 R = 6.371e6 # Earth's radius in meters # Initial conditions altitude = 300e3 # 300 km above surface r0 = np.array([R + altitude, 0]) # position vector v0 = np.array([0, 7700]) # velocity vector (tangent speed near orbit) # Time settings dt = 1 # time step (s) total_time = 10000 # seconds steps = int(total_time / dt) # Arrays to store trajectory positions = [] velocities = [] r = r0.copy() v = v0.copy() for _ in range(steps): # Record position positions.append(r.copy()) # Calculate acceleration distance = np.linalg.norm(r) acc = -G * M * r / distance**3 # Update velocity and position (Euler method) v += acc * dt r += v * dt # Stop if impact if np.linalg.norm(r) <= R: break positions = np.array(positions) # Plot trajectory plt.figure(figsize=(8, 8)) plt.plot(positions[:,0]/1000, positions[:,1]/1000, label=\"Payload Trajectory\") earth = plt.Circle((0, 0), R/1000, color='blue', alpha=0.5, label=\"Earth\") plt.gca().add_patch(earth) plt.xlabel(\"X (km)\") plt.ylabel(\"Y (km)\") plt.title(\"Trajectory of a Freely Released Payload Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.show() \ud83d\udd0d Example Scenarios Scenario Initial Speed (m/s) Resulting Trajectory Below Orbital Speed (~7.5 km/s) 6000 Sub-orbital / Reentry Circular Orbit 7670 Elliptical Orbit Escape Velocity (~11.2 km/s) 11200 Parabolic Escape Excess Velocity 12000 Hyperbolic Escape \ud83d\udcca Visual Interpretation If the velocity is too low , the payload returns to Earth. If it's just right , it stays in orbit. If too high , it escapes Earth\u2019s gravity. \ud83d\udef0\ufe0f Applications Satellite deployment : Achieving elliptical or circular orbit Space missions : Transfer orbits to Moon, Mars, etc. Reentry planning : Ensuring objects return predictably Planetary science : Studying how objects behave near planetary bodies \u2705 Conclusion Simulating payload trajectories near Earth highlights the beauty and complexity of celestial mechanics . Even slight changes in initial speed or angle drastically affect the path \u2014 making simulation tools and understanding physics absolutely vital for modern space missions.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"\ud83d\ude80 Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory is governed by initial velocity, release angle, altitude, and the gravitational pull of Earth. This creates a spectrum of possible paths \u2014 elliptical , parabolic , or hyperbolic \u2014 depending on its energy and direction . Understanding these trajectories is crucial for: Orbital insertion Satellite deployment Reentry planning Escape missions","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"","title":"\ud83c\udf0d Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"\\[ F = \\frac{GMm}{r^2} \\] Where: - \\( F \\) is the gravitational force - \\( G = 6.67430 \\times 10^{-11} \\ \\text{m}^3/\\text{kg}/\\text{s}^2 \\) - \\( M \\) is Earth\u2019s mass - \\( m \\) is the payload mass - \\( r \\) is the distance from Earth's center","title":"\ud83e\uddf2 Newton\u2019s Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equation-of-motion-2d","text":"To simulate motion in a plane, we use Newton's Second Law and integrate position and velocity: \\[ \\vec{a} = - \\frac{GM}{r^3} \\vec{r} \\] We use numerical methods like Euler or Runge-Kutta (RK4) to simulate the motion over time.","title":"\ud83d\udd04 Equation of Motion (2D)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Elliptical : Bound orbit (total mechanical energy < 0) Parabolic : Escape at exactly escape velocity (total energy = 0) Hyperbolic : Escape with excess velocity (total energy > 0) The total specific energy: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\]","title":"\u2728 Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 R = 6.371e6 # Earth's radius in meters # Initial conditions altitude = 300e3 # 300 km above surface r0 = np.array([R + altitude, 0]) # position vector v0 = np.array([0, 7700]) # velocity vector (tangent speed near orbit) # Time settings dt = 1 # time step (s) total_time = 10000 # seconds steps = int(total_time / dt) # Arrays to store trajectory positions = [] velocities = [] r = r0.copy() v = v0.copy() for _ in range(steps): # Record position positions.append(r.copy()) # Calculate acceleration distance = np.linalg.norm(r) acc = -G * M * r / distance**3 # Update velocity and position (Euler method) v += acc * dt r += v * dt # Stop if impact if np.linalg.norm(r) <= R: break positions = np.array(positions) # Plot trajectory plt.figure(figsize=(8, 8)) plt.plot(positions[:,0]/1000, positions[:,1]/1000, label=\"Payload Trajectory\") earth = plt.Circle((0, 0), R/1000, color='blue', alpha=0.5, label=\"Earth\") plt.gca().add_patch(earth) plt.xlabel(\"X (km)\") plt.ylabel(\"Y (km)\") plt.title(\"Trajectory of a Freely Released Payload Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.show()","title":"\ud83e\uddea Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#example-scenarios","text":"Scenario Initial Speed (m/s) Resulting Trajectory Below Orbital Speed (~7.5 km/s) 6000 Sub-orbital / Reentry Circular Orbit 7670 Elliptical Orbit Escape Velocity (~11.2 km/s) 11200 Parabolic Escape Excess Velocity 12000 Hyperbolic Escape","title":"\ud83d\udd0d Example Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visual-interpretation","text":"If the velocity is too low , the payload returns to Earth. If it's just right , it stays in orbit. If too high , it escapes Earth\u2019s gravity.","title":"\ud83d\udcca Visual Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#applications","text":"Satellite deployment : Achieving elliptical or circular orbit Space missions : Transfer orbits to Moon, Mars, etc. Reentry planning : Ensuring objects return predictably Planetary science : Studying how objects behave near planetary bodies","title":"\ud83d\udef0\ufe0f Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"Simulating payload trajectories near Earth highlights the beauty and complexity of celestial mechanics . Even slight changes in initial speed or angle drastically affect the path \u2014 making simulation tools and understanding physics absolutely vital for modern space missions.","title":"\u2705 Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Interference Patterns on a Water Surface \ud83c\udfaf Motivation Interference occurs when waves from different sources overlap. On a water surface, this is easily observed when ripples from multiple points meet, forming distinctive interference patterns. These patterns demonstrate how waves combine through constructive interference (amplifying) and destructive interference (canceling out). Studying interference patterns helps us: - Understand wave behavior in a visual, intuitive way. - Explore wave superposition and the effects of source geometry. - Apply core physics concepts to real-world systems like sonar, optics, and wireless communication. \ud83d\udcd8 Theoretical Foundation \u2705 Single Disturbance Wave Equation A circular wave from a point source located at \\((x_0, y_0)\\) is described by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) : water surface displacement at position \\((x, y)\\) and time \\(t\\) - \\(A\\) : amplitude of the wave - \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number ( \\(\\lambda\\) = wavelength) - \\(\\omega = 2\\pi f\\) : angular frequency ( \\(f\\) = frequency) - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from the source - \\(\\phi\\) : initial phase \u2705 Superposition Principle When multiple sources emit waves, the total displacement is the sum of individual displacements : \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where \\(N\\) is the number of sources. All sources are assumed coherent and have the same amplitude, wavelength, and frequency. \ud83e\uddea Python Simulation import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1.0 wavelength = 1.0 frequency = 1.0 omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength phi = 0.0 t = 0.0 # fixed time snapshot # Grid definition x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) # Regular polygon vertices def regular_polygon_vertices(n, radius=2.0, center=(0, 0)): return [ ( center[0] + radius * np.cos(2 * np.pi * i / n), center[1] + radius * np.sin(2 * np.pi * i / n) ) for i in range(n) ] # Single source wave def single_wave(x, y, x0, y0, t, A, k, omega, phi): r = np.sqrt((x - x0)**2 + (y - y0)**2) return A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Simulation function def simulate_interference_pattern(n_sources, title=\"Polygon Interference Pattern\", radius=2.0, t=0.0): sources = regular_polygon_vertices(n=n_sources, radius=radius) eta_total = np.zeros_like(X) for (x0, y0) in sources: eta_total += single_wave(X, Y, x0, y0, t, A, k, omega, phi) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_total, levels=100, cmap='RdBu') plt.colorbar(label='Wave Displacement \u03b7(x, y)') for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'Wave Interference Pattern - {title}') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.grid(True) plt.tight_layout() plt.show() # Run simulations simulate_interference_pattern(n_sources=3, title=\"Equilateral Triangle\") simulate_interference_pattern(n_sources=4, title=\"Square\") simulate_interference_pattern(n_sources=5, title=\"Regular Pentagon\") \ud83d\udcca Results & Analysis \ud83d\udd3a Equilateral Triangle Symmetrical three-source setup. Interference peaks form between each pair of sources. \u25fc\ufe0f Square More complex grid-like pattern. Strong central interference and diagonal symmetry. \ud83d\udd37 Pentagon Five-source symmetry creates rich and dense interference zones. Sharp wavefront overlaps near center. \ud83c\udfaf Key Observations More sources \\(\\Rightarrow\\) more intricate interference. Geometry of sources (polygon type) dictates pattern symmetry. Constructive interference \\(\\Rightarrow\\) high-displacement zones. Destructive interference \\(\\Rightarrow\\) null displacement regions. \u2705 Deliverables Summary \u2705 Python simulation for point sources placed in regular polygons \u2705 Mathematical derivation of wave equations \u2705 Graphical results showing interference regions \u2705 Clear explanation of wave superposition and pattern formation Let me know if you want this as .ipynb , animated, extended to 3D, or exported to PDF.","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap. On a water surface, this is easily observed when ripples from multiple points meet, forming distinctive interference patterns. These patterns demonstrate how waves combine through constructive interference (amplifying) and destructive interference (canceling out). Studying interference patterns helps us: - Understand wave behavior in a visual, intuitive way. - Explore wave superposition and the effects of source geometry. - Apply core physics concepts to real-world systems like sonar, optics, and wireless communication.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-foundation","text":"","title":"\ud83d\udcd8 Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-disturbance-wave-equation","text":"A circular wave from a point source located at \\((x_0, y_0)\\) is described by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) : water surface displacement at position \\((x, y)\\) and time \\(t\\) - \\(A\\) : amplitude of the wave - \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number ( \\(\\lambda\\) = wavelength) - \\(\\omega = 2\\pi f\\) : angular frequency ( \\(f\\) = frequency) - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from the source - \\(\\phi\\) : initial phase","title":"\u2705 Single Disturbance Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-principle","text":"When multiple sources emit waves, the total displacement is the sum of individual displacements : \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where \\(N\\) is the number of sources. All sources are assumed coherent and have the same amplitude, wavelength, and frequency.","title":"\u2705 Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1.0 wavelength = 1.0 frequency = 1.0 omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength phi = 0.0 t = 0.0 # fixed time snapshot # Grid definition x = np.linspace(-5, 5, 400) y = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x, y) # Regular polygon vertices def regular_polygon_vertices(n, radius=2.0, center=(0, 0)): return [ ( center[0] + radius * np.cos(2 * np.pi * i / n), center[1] + radius * np.sin(2 * np.pi * i / n) ) for i in range(n) ] # Single source wave def single_wave(x, y, x0, y0, t, A, k, omega, phi): r = np.sqrt((x - x0)**2 + (y - y0)**2) return A / np.sqrt(r + 1e-6) * np.cos(k * r - omega * t + phi) # Simulation function def simulate_interference_pattern(n_sources, title=\"Polygon Interference Pattern\", radius=2.0, t=0.0): sources = regular_polygon_vertices(n=n_sources, radius=radius) eta_total = np.zeros_like(X) for (x0, y0) in sources: eta_total += single_wave(X, Y, x0, y0, t, A, k, omega, phi) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_total, levels=100, cmap='RdBu') plt.colorbar(label='Wave Displacement \u03b7(x, y)') for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'Wave Interference Pattern - {title}') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.grid(True) plt.tight_layout() plt.show() # Run simulations simulate_interference_pattern(n_sources=3, title=\"Equilateral Triangle\") simulate_interference_pattern(n_sources=4, title=\"Square\") simulate_interference_pattern(n_sources=5, title=\"Regular Pentagon\")","title":"\ud83e\uddea Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#results-analysis","text":"","title":"\ud83d\udcca Results &amp; Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#equilateral-triangle","text":"Symmetrical three-source setup. Interference peaks form between each pair of sources.","title":"\ud83d\udd3a Equilateral Triangle"},{"location":"1%20Physics/3%20Waves/Problem_1/#square","text":"More complex grid-like pattern. Strong central interference and diagonal symmetry.","title":"\u25fc\ufe0f Square"},{"location":"1%20Physics/3%20Waves/Problem_1/#pentagon","text":"Five-source symmetry creates rich and dense interference zones. Sharp wavefront overlaps near center.","title":"\ud83d\udd37 Pentagon"},{"location":"1%20Physics/3%20Waves/Problem_1/#key-observations","text":"More sources \\(\\Rightarrow\\) more intricate interference. Geometry of sources (polygon type) dictates pattern symmetry. Constructive interference \\(\\Rightarrow\\) high-displacement zones. Destructive interference \\(\\Rightarrow\\) null displacement regions.","title":"\ud83c\udfaf Key Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables-summary","text":"\u2705 Python simulation for point sources placed in regular polygons \u2705 Mathematical derivation of wave equations \u2705 Graphical results showing interference regions \u2705 Clear explanation of wave superposition and pattern formation Let me know if you want this as .ipynb , animated, extended to 3D, or exported to PDF.","title":"\u2705 Deliverables Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \u26a1 Equivalent Resistance Using Graph Theory \ud83c\udfaf Motivation Calculating equivalent resistance is a key task in circuit analysis. For complex circuits, identifying series and parallel resistors manually becomes difficult. Graph theory allows us to represent circuits as graphs \u2014nodes are junctions, and edges are resistors with resistance as weight. This makes the problem algorithmic, automatable, and scalable. \ud83e\udde0 Core Concepts \u2705 Series Resistors If two resistors are connected end-to-end : \\[ R_{\\text{eq}} = R_1 + R_2 \\] This is because the same current flows through both, so voltages add up. \u2705 Parallel Resistors If two resistors are connected to the same pair of nodes: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\] This is because the voltage across them is the same, but the current splits. You get: \\[ I_{\\text{total}} = I_1 + I_2 = \\frac{V}{R_1} + \\frac{V}{R_2} \\Rightarrow \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\] \ud83e\uddfe Pseudocode FUNCTION EquivalentResistance(G, start, end): WHILE graph G has more than two nodes: FOR each node v in G: IF v has 2 neighbors u and w: // Series combination R_eq = R_uv + R_vw REMOVE node v ADD edge (u, w) with resistance R_eq FOR each pair of nodes u, v with multiple edges: // Parallel combination R_eq = 1 / (1/R1 + 1/R2 + ...) REMOVE all edges (u, v) ADD one edge (u, v) with R_eq RETURN resistance between start and end \ud83d\udc0d Python Code (NetworkX) import networkx as nx def reduce_series(G): modified = True while modified: modified = False for node in list(G.nodes): if G.degree(node) == 2 and node not in ('A', 'E'): # skip terminals u, v = list(G.neighbors(node)) R1 = G[u][node]['resistance'] R2 = G[node][v]['resistance'] G.add_edge(u, v, resistance=R1 + R2) G.remove_node(node) modified = True break def reduce_parallel(G): modified = True while modified: modified = False for u, v in list(G.edges): if G.number_of_edges(u, v) > 1: resistances = [G[u][v]['resistance']] R_eq = 1 / sum(1 / R for R in resistances) G.remove_edges_from([(u, v)]) G.add_edge(u, v, resistance=R_eq) modified = True break def equivalent_resistance(G, start, end): G = G.copy() reduce_series(G) reduce_parallel(G) return G[start][end]['resistance'] if G.has_edge(start, end) else None \ud83d\udd0c Circuit Example Nodes: A, B, C, D, E Resistors: A\u2013B = 5\u03a9 B\u2013C = 10\u03a9 A\u2013C = 20\u03a9 C\u2013D = 10\u03a9 D\u2013E = 5\u03a9 C\u2013E = 10\u03a9 \ud83d\udcc9 Reduction Process Step Action Result A\u2013B\u2013C Series: \\(5 + 10\\) A\u2013C = 15\u03a9 A\u2013C (x2) Parallel: \\(1/R = 1/15 + 1/20\\) A\u2013C \u2248 8.57\u03a9 C\u2013D\u2013E Series: \\(10 + 5\\) C\u2013E = 15\u03a9 C\u2013E (x2) Parallel: \\(1/R = 1/10 + 1/15\\) C\u2013E = 6\u03a9 A\u2013C\u2013E Final: \\(8.57 + 6\\) \u2248 30\u03a9 \u2705 Final Answer Equivalent Resistance between A and E: \\[ R_{\\text{eq}} \\approx 30\\ \\Omega \\] \ud83d\ude80 Insights & Extensions This method works on any circuit that can be reduced by series/parallel rules. Graph algorithms enable automation and scalability . Can be extended to: Support voltage/current sources. Handle Wheatstone bridges via Y-\u0394 transformations. GUI for interactive circuit editing.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"\u26a1 Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a key task in circuit analysis. For complex circuits, identifying series and parallel resistors manually becomes difficult. Graph theory allows us to represent circuits as graphs \u2014nodes are junctions, and edges are resistors with resistance as weight. This makes the problem algorithmic, automatable, and scalable.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#core-concepts","text":"","title":"\ud83e\udde0 Core Concepts"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-resistors","text":"If two resistors are connected end-to-end : \\[ R_{\\text{eq}} = R_1 + R_2 \\] This is because the same current flows through both, so voltages add up.","title":"\u2705 Series Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-resistors","text":"If two resistors are connected to the same pair of nodes: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\] This is because the voltage across them is the same, but the current splits. You get: \\[ I_{\\text{total}} = I_1 + I_2 = \\frac{V}{R_1} + \\frac{V}{R_2} \\Rightarrow \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\]","title":"\u2705 Parallel Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"FUNCTION EquivalentResistance(G, start, end): WHILE graph G has more than two nodes: FOR each node v in G: IF v has 2 neighbors u and w: // Series combination R_eq = R_uv + R_vw REMOVE node v ADD edge (u, w) with resistance R_eq FOR each pair of nodes u, v with multiple edges: // Parallel combination R_eq = 1 / (1/R1 + 1/R2 + ...) REMOVE all edges (u, v) ADD one edge (u, v) with R_eq RETURN resistance between start and end","title":"\ud83e\uddfe Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-code-networkx","text":"import networkx as nx def reduce_series(G): modified = True while modified: modified = False for node in list(G.nodes): if G.degree(node) == 2 and node not in ('A', 'E'): # skip terminals u, v = list(G.neighbors(node)) R1 = G[u][node]['resistance'] R2 = G[node][v]['resistance'] G.add_edge(u, v, resistance=R1 + R2) G.remove_node(node) modified = True break def reduce_parallel(G): modified = True while modified: modified = False for u, v in list(G.edges): if G.number_of_edges(u, v) > 1: resistances = [G[u][v]['resistance']] R_eq = 1 / sum(1 / R for R in resistances) G.remove_edges_from([(u, v)]) G.add_edge(u, v, resistance=R_eq) modified = True break def equivalent_resistance(G, start, end): G = G.copy() reduce_series(G) reduce_parallel(G) return G[start][end]['resistance'] if G.has_edge(start, end) else None","title":"\ud83d\udc0d Python Code (NetworkX)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuit-example","text":"Nodes: A, B, C, D, E Resistors: A\u2013B = 5\u03a9 B\u2013C = 10\u03a9 A\u2013C = 20\u03a9 C\u2013D = 10\u03a9 D\u2013E = 5\u03a9 C\u2013E = 10\u03a9","title":"\ud83d\udd0c Circuit Example"},{"location":"1%20Physics/5%20Circuits/Problem_1/#reduction-process","text":"Step Action Result A\u2013B\u2013C Series: \\(5 + 10\\) A\u2013C = 15\u03a9 A\u2013C (x2) Parallel: \\(1/R = 1/15 + 1/20\\) A\u2013C \u2248 8.57\u03a9 C\u2013D\u2013E Series: \\(10 + 5\\) C\u2013E = 15\u03a9 C\u2013E (x2) Parallel: \\(1/R = 1/10 + 1/15\\) C\u2013E = 6\u03a9 A\u2013C\u2013E Final: \\(8.57 + 6\\) \u2248 30\u03a9","title":"\ud83d\udcc9 Reduction Process"},{"location":"1%20Physics/5%20Circuits/Problem_1/#final-answer","text":"Equivalent Resistance between A and E: \\[ R_{\\text{eq}} \\approx 30\\ \\Omega \\]","title":"\u2705 Final Answer"},{"location":"1%20Physics/5%20Circuits/Problem_1/#insights-extensions","text":"This method works on any circuit that can be reduced by series/parallel rules. Graph algorithms enable automation and scalability . Can be extended to: Support voltage/current sources. Handle Wheatstone bridges via Y-\u0394 transformations. GUI for interactive circuit editing.","title":"\ud83d\ude80 Insights &amp; Extensions"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}